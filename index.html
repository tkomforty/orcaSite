<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Open Graph / Social Media Preview Tags -->
    <meta property="og:title" content="Orcas Audio - tailored sonic processing">
    <meta property="og:description" content="Inventive VST plugins featuring ocean-inspired audio processing. Undertow reverb/delay, Monsoon Drive saturation, and Quad Cascade delay effects.">
    <meta property="og:image" content="https://raw.githubusercontent.com/tkomforty/orcaSite/main/orca_Site_preview.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://orcasaudio.com">
    
    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Orcas Audio - tailored sonic processing">
    <meta name="twitter:description" content="Professional VST plugins featuring ocean-inspired audio processing.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/tkomforty/orcaSite/main/orca_Site_preview.png">
    
    <title>Orcas Audio - tailored sonic processing</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'CustomTypeface';
            src: url('https://raw.githubusercontent.com/tkomforty/orcaSite/main/customTypeface.ttf') format('truetype');
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            background: #000;
            font-family: 'Inter', sans-serif;
        }

        canvas#oceanCanvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 0;
        }

        /* Content Layer */
        .content-layer {
            position: relative;
            z-index: 1;
            padding: 40px;
            min-height: 100vh;
        }

        /* Typography */
.title {
    font-family: 'CustomTypeface', 'Inter', sans-serif;
    font-size: 5.5em; /* Slightly increased size */
    font-weight: 700;
    font-style: italic;
    color: transparent;
    margin-bottom: 20px;
    text-align: left;
    letter-spacing: 12px; /* Increased letter spacing */
    background: linear-gradient(to bottom, white, blue);
    -webkit-background-clip: text;
    background-clip: text;
    text-shadow:
        0 2px 12px rgba(0, 0, 0, 0.5),   /* Soft black glow */
        0 4px 24px rgba(120, 0, 0, 0.3);   /* Additional soft black glow */
     /* Add this line for the white border */
    display: inline-block;     /* Add this line so the border fits the text */
    padding: 10px 20px;         /* Optional: adds space between text and border */
    box-sizing: border-box;   /* Ensures padding doesn't push out the border */
}

        .header {
            font-family: 'CustomTypeface', 'Inter', sans-serif; /* Use custom font */
            font-size: 1.5em; /* Smaller font size */
            font-weight: 600;
            color: #333; /* Softer black color */
            margin-bottom: 40px;
            text-align: left;
            letter-spacing: 4px; /* Increased kerning */
            font-style: italic; /* Italicized */
        }

        .section-divider {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #000;
            margin: 40px 0;
            white-space: pre;
            line-height: 1;
        }

        .plugin-section {
            margin-bottom: 60px;
        }

.plugin-title {
    font-family: 'CustomTypeface', 'Inter', sans-serif;
    font-size: 3em;           /* Increased size */
    font-weight: 400;
    color: #000;               /* Black text */
    margin-bottom: 20px;
    font-style: italic;       /* This makes the text italic */

    /* Removed text-shadow to eliminate glow */
}

        .plugin-content {
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }

        .plugin-image {
            flex: 0 0 400px;
            max-width: 400px;
            cursor: pointer; /* Add cursor pointer to indicate it's clickable */
        }

        .plugin-image img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            /* This will prevent the image from jumping on click */
            vertical-align: middle; 
        }

        .plugin-info {
            flex: 1;
            color: #000;
        }

.plugin-description {
    font-family: 'CustomTypeface', 'Inter', sans-serif;
    font-size: 1.51em;
    line-height: 1.6;
    margin-bottom: 20px;
    color: #000; /* Darker blue base */
    text-shadow:
        0 0 8px #225384,
        0 0 8px #11293f,
        0 0 32px #225384;
}

.plugin-features {
    font-family: 'CustomTypeface', 'Inter', sans-serif;
    list-style: none;
    margin-bottom: 25px;
    font-size: 1.4em; /* <-- Added line */
}

.plugin-features li {
    font-family: 'CustomTypeface', 'Inter', sans-serif;
    padding: 4px 0;
    position: relative;
    padding-left: 20px;
    /* font-size: 1.4em;  <-- You could also add it here if you want even more control */
}

        .plugin-features li::before {
            content: "•";
            position: absolute;
            left: 0;
            font-weight: bold;
            font-family: 'CustomTypeface', 'Inter', sans-serif;

        }

        .plugin-price {
            
            font-size: 1.5em;
            font-weight: 700;
            color: #000;
            margin-bottom: 15px;
        }
        
        /* --- Buy Button Glow Effect --- */
        stripe-buy-button {
            border-radius: 50px; /* Rounded to match the button's shape */
            overflow: hidden;   /* Ensures glow conforms to the radius */
            box-shadow: 0 0 10px 2px rgba(108, 166, 205, 0.4); /* Soft, subtle dark blue glow */
            transition: box-shadow 0.3s ease-in-out; /* Smooth transition */
        }

        stripe-buy-button:hover {
            box-shadow: 0 0 16px 4px rgba(108, 166, 205, 0.6); /* Intensified blue glow on hover */
        }
        
        /* Styles for the image popup modal */
        .image-popup-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0); /* Initial state for GSAP animation */
            display: none; 
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .image-popup-modal-content {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .image-popup-modal-content img {
            width: auto;
            height: auto;
            max-width: 90vw;
            max-height: 85vh;
            border-radius: 8px;
        }

        .close-popup {
            position: fixed; /* Changed from absolute to fixed */
            top: 20px;
            right: 30px;
            font-size: 40px;
            color: #fff;
            cursor: pointer;
            font-weight: bold;
            z-index: 1001; /* Ensure it's above the image */
            opacity: 0; /* Initial state for GSAP animation */
            pointer-events: none; /* Can't be clicked when invisible */
        }
        
        /* --- Cursor Particle Effect --- */
        .particle {
            position: fixed;
            left: 0;
            top: 0;
            /* removed border-radius to make them square */
            pointer-events: none;
            z-index: 9999;
            animation: particle-animation 1s ease-out forwards;
        }

        @keyframes particle-animation {
            to {
                opacity: 0;
                transform: translate(var(--x), var(--y));
            }
        }
        
        /* --- NEW STYLES FOR INFO SECTIONS --- */
        .info-section-container {
            padding: 20px 0;
            color: #ccc; /* Light gray for readability on the animated background */
            text-align: left; /* Left align text by default */
        }

        .info-section {
            margin-bottom: 40px;
        }

        .info-title {
            font-size: 1.3em;
            font-weight: 600;
            color: #fff; /* White title */
            margin-bottom: 20px;
            font-family: 'CustomTypeface', 'Inter', sans-serif;
            font-style: italic;
            letter-spacing: 2px;
        }

        .info-text, .info-list {
            font-family: 'CustomTypeface', 'Inter', sans-serif;
            font-size: 1.20em; /* Reduced font size */
            line-height: 1.0;
            max-width: 800px; /* Constrain width for readability */
        }

        .info-list {
            list-style: none;
            padding: 0;
        }

        .info-list li {
            margin-bottom: 10px;
        }

        /* --- Footer --- */
        .site-footer {
            font-family: 'CustomTypeface', 'Inter', sans-serif;
            position: relative;
            z-index: 1;
            padding: 20px;
            text-align: center;
            color: #ccc;
            font-size: 1.2em;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .content-layer {
                padding: 20px;
            }
            
            .title {
                font-size: 3.5em; /* Adjusted size for mobile */
                text-align: center;
            }
            
            .header {
                font-size: 1.2em; /* Adjusted size for mobile */
                text-align: center;
            }

            .plugin-content {
                flex-direction: column;
                gap: 20px;
            }

            .plugin-image {
                flex: none;
                max-width: 100%;
            }

            .plugin-info {
                font-family: 'CustomTypeface', 'Inter', sans-serif;
                font-size: 1.2em;
                display: flex;
                flex-direction: column;
                align-items: center;
            }

            .plugin-title,
            .plugin-description,
            .plugin-features,
            .plugin-price {
                text-align: center;
            }
            
            .plugin-features li {
                                                font-family: 'CustomTypeface', 'Inter', sans-serif;

                
                padding-left: 0; /* Remove left padding */
                text-align: center;
                list-style-position: inside; /* Helps center the bullet */
            }

            .plugin-features li::before {
                                                font-family: 'CustomTypeface', 'Inter', sans-serif;

                content: none; /* Hide the custom bullet as we use default now */
            }

            /* --- NEW RESPONSIVE STYLES --- */
            .info-section-container {
                                                font-family: 'CustomTypeface', 'Inter', sans-serif;

                text-align: center; /* Center text on mobile */
            }
            .info-title {
                                                font-family: 'CustomTypeface', 'Inter', sans-serif;

                font-size: 1.5em;
            }
            .info-text, .info-list {
                                                font-family: 'CustomTypeface', 'Inter', sans-serif;

                font-size: 1em;
                padding: 0 15px; /* Add some horizontal padding */
                margin-left: auto;
                margin-right: auto;
            }
        }

        @supports (-webkit-touch-callout: none) {
            html, body {
                height: -webkit-fill-available;
            }
        }
    </style>
    <script async src="https://js.stripe.com/v3/buy-button.js"></script>
    <!-- GSAP Libraries for advanced animation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/Flip.min.js"></script>
</head>
<body>
    <!-- Image Popup Modal -->
    <div id="imagePopup" class="image-popup-modal">
        <div class="image-popup-modal-content">
            <!-- The clicked image will be moved here by JavaScript -->
        </div>
        <!-- Moved close button to be a direct child of the modal -->
        <span class="close-popup" id="closePopup">&times;</span>
    </div>

    <!-- Content Layer -->
    <div class="content-layer">
        <h1 class="title">Orcas Audio</h1>
        <h2 class="header">tailored sonic processing</h2>
        
        <div class="section-divider">//==============================================================================</div>
        
        <div class="plugin-section">
            <h3 class="plugin-title">Undertow</h3>
            <div class="plugin-content">
                <div class="plugin-image">
                    <img src="https://raw.githubusercontent.com/tkomforty/orcaSite/main/undertowVST.png" 
                         alt="Undertow VST Plugin Interface">
                </div>
                <div class="plugin-info">
                    <p class="plugin-description">
                        Dive deep into immersive soundscapes with an
                        advanced reverb algorithm paired with innovative delay processing. Create waves of audio that ebb and flow with musical velocity.
                    </p>
                    <ul class="plugin-features">
                        <li>Advanced Reverb Engine with freeze-control for atmosphere creation</li>
                        <li>Inline Analog Delay with Tempo Sync</li>
                        <li>Analog inspired soft-clipper for harmonic saturation</li>
                        <li>Low CPU Usage for Studio or Live Performance</li>
                        <li>Compatible with All Major DAWs in VST3 format (AU coming soon)</li>
                    </ul>
                    <div class="plugin-price">$25</div>
                    <stripe-buy-button
                        buy-button-id="buy_btn_1RVzgJRoq3ytCMWwHfuNXOU4"
                        publishable-key="pk_test_51RVzbARoq3ytCMWwCkVu7Y9Xg3CTmCRbulhnFe14ocUvVq1J19mXbY4NXIKi2fT8HCKBqE1iSOj51FxiGqtfbVPm00dnSwA4Ky"
                    >
                    </stripe-buy-button>
                </div>
            </div>
        </div>
        
        <div class="section-divider">//==============================================================================</div>
        
        <div class="plugin-section">
            <h3 class="plugin-title">Quad Cascade</h3>
            <div class="plugin-content">
                <div class="plugin-image">
                    <img src="https://raw.githubusercontent.com/tkomforty/orcaSite/main/quadCascade.png" 
                         alt="Quad Cascade VST Plugin Interface">
                </div>
                <div class="plugin-info">
                    <p class="plugin-description">
                        Create cascading echoes and complex rhythmic patterns with a simple, but complex 
                        4-stage series analog delay. Each stage features independent feedback and gain controls, 
                        allowing for intricate delay textures and evolving soundscapes that build upon themselves.
                    </p>
                    <ul class="plugin-features">
                        <li>4-stage series analog delay for complex echo patterns</li>
                        <li>Independent feedback control for each delay stage</li>
                        <li>Individual gain controls for precise level balancing</li>
                        <li>Built-in soft clipper for warm analog saturation</li>
                        <li>Level trim control for optimal output management</li>
                        <li>Compatible with All Major DAWs in VST3 format (AU coming soon)</li>
                    </ul>
                    <div class="plugin-price">$25</div>
                     <stripe-buy-button
                        buy-button-id="buy_btn_1RVzgJRoq3ytCMWwHfuNXOU4"
                        publishable-key="pk_test_51RVzbARoq3ytCMWwCkVu7Y9Xg3CTmCRbulhnFe14ocUvVq1J19mXbY4NXIKi2fT8HCKBqE1iSOj51FxiGqtfbVPm00dnSwA4Ky"
                    >
                    </stripe-buy-button>
                </div>
            </div>
        </div>
        <div class="section-divider">//==============================================================================</div>

         <div class="plugin-section">
            <h3 class="plugin-title">Monsoon Drive (coming soon)</h3>
            <div class="plugin-content">
                <div class="plugin-image">
                    <img src="https://raw.githubusercontent.com/tkomforty/orcaSite/main/HarmBass.png" 
                         alt="HarmBass VST Plugin Interface">
                </div>
                <div class="plugin-info">
                    <p class="plugin-description">
                        Transform your low end with this powerful bass harmonic saturator featuring four meticulously 
                        modeled distortion algorithms based on real hardware. Add warmth, grit, and character to your bass 
                        tracks with precision frequency control and authentic analog saturation.
                    </p>
                    <ul class="plugin-features">
                        <li>Four distortion algorithms modeled after real hardware units</li>
                        <li>Dedicated bass frequency control for targeted saturation</li>
                        <li>Soft clipper algorithm for smooth harmonic enhancement</li>
                        <li>Analog-modeled saturation for authentic vintage warmth</li>
                        <li>Low CPU usage optimized for bass processing</li>
                        <li>Compatible with All Major DAWs in VST3 format (AU coming soon)</li>
                    </ul>
                    
                
                    
                </div>
            </div>
        </div>
        
        <!-- === INFO CONTENT STARTS HERE === -->
        <div class="section-divider" style="color: #000;">//==============================================================================</div>
    
        <div class="info-section-container">
            <div class="info-section">
                <h3 class="info-title">Installation</h3>
                <p class="info-text">
                    After downloading, simply copy the VST3 file to your computer's shared VST3 folder, 
                    which is typically located at Program Files\Common Files\VST3 on Windows. Once the file is in place, 
                    open your DAW and rescan your plugin folder to make the plugin available in your effects list. 
                    The plugin will then appear in your DAW's plugin browser and be ready to use in your projects.
                </p>
            </div>

        
        <div class="info-section-container">
            <div class="info-section">
                <h3 class="info-title">Limitation of Liability</h3>
                <p class="info-text">
                    Orcas Audio plugins are provided "as is" without warranty. Our liability is limited to the purchase price of the software.
                </p>
            </div>
        
            <div class="info-section">
                <h3 class="info-title">Delivery</h3>
                <ul class="info-list">
                    <li>Digital download links provided immediately after purchase</li>
                    <li>Installation instructions included with download</li>
                </ul>
            </div>
        
            <div class="info-section">
                <h3 class="info-title">Refund</h3>
                 <ul class="info-list">
                    <li>Email <a href="mailto:orcasaudio@gmail.com" style="color: #8cb8d3; text-decoration: none;">orcasaudio@gmail.com</a></li>
                    <li>Include the reason for your refund request</li>
                    <li>Refunds will be processed within 3-5 business days to your original payment method</li>
                    <li>Refunds are available for 14 days from the date of purchase.</li>
                </ul>
            </div>

            <div class="info-section">
                <h3 class="info-title">Software Distribution Restrictions</h3>
                <p class="info-text">
                    You may not share, distribute, or redistribute these plugins in any form without explicit written authorization from Orcas Audio. This prohibition includes:
                </p>
                 <ul class="info-list" style="padding-top: 10px;">
                    <li>Sharing files through file-sharing platforms or websites</li>
                    <li>Including plugins in software bundles or compilation packages</li>
                    <li>Distributing via physical media, online downloads, or promotional materials</li>
                    <li>Embedding or integrating the software into other applications, games, or digital audio workstations</li>
                    <li>Commercial or non-commercial redistribution of any kind</li>
                    <li style="padding-top: 10px;">Only the original purchaser may use the licensed software under the terms of this agreement.</li>
                </ul>
            </div>
        </div>
        <!-- === INFO CONTENT ENDS HERE === -->
        
    </div>

    <!-- Footer added here -->
    <footer class="site-footer">
        © Orcas Audio 2025
    </footer>

    <script>
        let canvas, gl;
        let program;
        let startTime = Date.now();
        let mouse = { x: 0, y: 0 };
        let splashes = [];
        const MAX_SPLASHES = 10;

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                        (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

        // --- Particle Effect Logic ---
        let canSpawnParticle = true;
        const blueShades = [
            'rgba(25, 25, 112, 0.7)', // Midnight Blue
            'rgba(0, 0, 139, 0.7)',   // Dark Blue
            'rgba(0, 0, 205, 0.7)',   // Medium Blue
            'rgba(65, 105, 225, 0.7)' // Royal Blue
        ];
        
        function spawnParticle(x, y) {
            if (!canSpawnParticle) return;
            canSpawnParticle = false;

            const particle = document.createElement('div');
            particle.className = 'particle';
            document.body.appendChild(particle);

            const size = Math.floor(Math.random() * 2) + 1; // Particle size from 1px to 2px
            const destinationX = (Math.random() - 0.5) * 100; // Random X destination
            const destinationY = (Math.random() - 0.5) * 100; // Random Y destination
            const color = blueShades[Math.floor(Math.random() * blueShades.length)];


            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            particle.style.left = `${x - size / 2}px`;
            particle.style.top = `${y - size / 2}px`;
            particle.style.backgroundColor = color;
            
            // Set CSS variables for the animation
            particle.style.setProperty('--x', `${destinationX}px`);
            particle.style.setProperty('--y', `${destinationY}px`);

            // Remove the particle from the DOM after animation
            setTimeout(() => {
                particle.remove();
            }, 1000); // Animation duration is 1s

            // Throttle particle creation
            setTimeout(() => {
                canSpawnParticle = true;
            }, 20); // Create a new particle at most every 20ms
        }
        
        window.onload = function() {
            canvas = document.createElement('canvas');
            canvas.id = 'oceanCanvas';
            document.body.insertBefore(canvas, document.body.firstChild);

            resize();

            const contextAttributes = {
                alpha: false, antialias: false, preserveDrawingBuffer: false, stencil: false,
                depth: false, failIfMajorPerformanceCaveat: false, powerPreference: "default"
            };

            gl = canvas.getContext('webgl2', contextAttributes);
            if (!gl) {
                gl = canvas.getContext('webgl', contextAttributes) ||
                     canvas.getContext('experimental-webgl', contextAttributes);
            }

            if (!gl) {
                const msg = document.createElement('div');
                msg.style.color = 'white'; msg.style.position = 'absolute';
                msg.style.top = '50%'; msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.zIndex = '2';
                msg.innerHTML = 'Your browser does not support WebGL, which is required for the background animation.';
                document.body.appendChild(msg);
                return;
            }

            gl.clear(gl.COLOR_BUFFER_BIT);
            program = createProgram(gl, vertexShader, fragmentShader);
            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);
            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);
            window.addEventListener('resize', resize, false);

            const unlockAudio = function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createBufferSource();
                source.buffer = audioContext.createBuffer(1, 1, 22050);
                source.connect(audioContext.destination);
                source.start(0);
                document.body.removeEventListener('touchstart', unlockAudio);
                document.body.removeEventListener('touchend', unlockAudio);
                document.body.removeEventListener('click', unlockAudio);
            };
            document.body.addEventListener('touchstart', unlockAudio, {passive: true, once: true});
            document.body.addEventListener('click', unlockAudio, {passive: true, once: true});

            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            canvas.addEventListener('touchcancel', handleTouchEnd, {passive: false});
            
            // Add mousemove listener for particle effect
            window.addEventListener('mousemove', (e) => spawnParticle(e.clientX, e.clientY), false);
            
            canvas.addEventListener('mousemove', updateMouse, false);
            canvas.addEventListener('mousedown', handleClick, false);

            for (let i = 0; i < MAX_SPLASHES; i++) {
                splashes.push({ active: 0, worldX: 0, worldZ: 0, time: 0, strength: 0, particleCount: 0 });
            }

            // --- GSAP Image Popup Logic ---
            gsap.registerPlugin(Flip);

            const popup = document.querySelector('#imagePopup');
            const popupContent = document.querySelector('.image-popup-modal-content');
            const closeButton = document.querySelector('#closePopup');
            const pluginImageContainers = document.querySelectorAll('.plugin-image');
            let originalParent = null;
            let activeImage = null;
            let isAnimating = false; // Flag to prevent re-triggering animations

            pluginImageContainers.forEach(container => {
                container.addEventListener('click', () => {
                    if (isAnimating || activeImage) return;
                    isAnimating = true;
                    
                    activeImage = container.querySelector('img');
                    originalParent = container;

                    const state = Flip.getState(activeImage);

                    popup.style.display = 'flex';
                    popupContent.appendChild(activeImage);

                    Flip.from(state, {
                        duration: 0.6,
                        ease: 'power2.inOut',
                        absolute: true,
                        onComplete: () => {
                            isAnimating = false;
                        }
                    });
                    
                    gsap.to(popup, { backgroundColor: 'rgba(0,0,0,0.8)', duration: 0.5 });
                    // Fade in the close button after the main animation starts
                    gsap.to(closeButton, { opacity: 1, pointerEvents: 'auto', delay: 0.3, duration: 0.3 });
                });
            });

            const closeThePopup = () => {
                if (isAnimating || !activeImage || !originalParent) return;
                isAnimating = true;

                // Immediately fade out the close button
                gsap.to(closeButton, { opacity: 0, pointerEvents: 'none', duration: 0.2 });

                const state = Flip.getState(activeImage);
                originalParent.appendChild(activeImage);

                Flip.from(state, {
                    duration: 0.6,
                    ease: 'power2.inOut',
                    absolute: true,
                    onComplete: () => {
                        activeImage = null;
                        originalParent = null;
                        isAnimating = false;
                    }
                });
                
                gsap.to(popup, {
                    backgroundColor: 'rgba(0,0,0,0)', 
                    duration: 0.5,
                    onComplete: () => {
                        popup.style.display = 'none';
                    }
                });
            };

            closeButton.addEventListener('click', e => {
                e.stopPropagation();
                closeThePopup();
            });

            popup.addEventListener('click', () => {
                closeThePopup();
            });


            animate();

            setTimeout(function() {
                resize();
                if (isIOS) {
                    console.log("iOS detected, initializing touch handling for ocean sim");
                }
            }, 100);

            console.log("Ocean User Agent: " + navigator.userAgent);
            console.log("Is iOS: " + isIOS);
            console.log("Max Touch points: " + navigator.maxTouchPoints);
        };

        function resize() {
            let width = window.innerWidth;
            let height = window.innerHeight;

            if (isIOS) {
                const isLandscape = window.innerWidth > window.innerHeight;
                if (isLandscape) {
                    width = document.documentElement.clientWidth;
                    height = document.documentElement.clientHeight;
                }
            }

            const pixelRatio = window.devicePixelRatio || 1;
            if (canvas) {
                canvas.width = width * pixelRatio;
                canvas.height = height * pixelRatio;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                if (gl) {
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
            }
            console.log(`Ocean Canvas resized: ${width}x${height}, Pixel ratio: ${pixelRatio}`);
        }

        function updateMouse(e) {
            e.preventDefault();
            mouse.x = e.clientX / window.innerWidth;
            mouse.y = 1.0 - e.clientY / window.innerHeight;
        }

        function screenToWorld(screenX, screenY, camZ) {
            if (screenX.clientX !== undefined) {
                screenY = screenX.clientY;
                screenX = screenX.clientX;
            }
            const aspectRatio = canvas.width / canvas.height;
            const x = ((screenX / window.innerWidth) * 2.0 - 1.0) * aspectRatio;
            const y = ((window.innerHeight - screenY) / window.innerHeight) * 2.0 - 1.0;
            const cameraHeight = 5.0;
            let dirX = x;
            let dirY = -2.0; 
            let dirZ = y; 
            const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
            const normDirX = dirX / length;
            const normDirY = dirY / length;
            const normDirZ = dirZ / length;
            const t = -cameraHeight / normDirZ; 
            const worldX = 0 + normDirX * t; 
            const worldZRender = camZ + normDirY * t; 
            return { x: worldX, z: worldZRender };
        }

        function handleClick(e) {
            e.preventDefault();
            const now = (Date.now() - startTime) / 1000.0;
            const camZ = now * 2.0; 
            const worldPos = screenToWorld(e.clientX, e.clientY, camZ);
            createSplash(worldPos.x, worldPos.z, now);
        }

        function createSplash(worldX, worldZ, now) {
            let oldestIndex = 0;
            let oldestTime = Infinity;
            for (let i = 0; i < MAX_SPLASHES; i++) {
                if (splashes[i].active === 0) {
                    oldestIndex = i;
                    break;
                }
                if (splashes[i].time < oldestTime) {
                    oldestTime = splashes[i].time;
                    oldestIndex = i;
                }
            }
            const strength = 0.3 + Math.random() * 0.3;
            const particleCount = 3 + Math.floor(Math.random() * 3);
            splashes[oldestIndex] = {
                active: 1, worldX: worldX, worldZ: worldZ,
                time: now, strength: strength, particleCount: particleCount
            };
            console.log("Splash created at (world):", worldX.toFixed(2), worldZ.toFixed(2), "time:", now.toFixed(2));
        }

        let touchActive = false;
        let lastTouchTime = 0;

        function handleTouchStart(e) {
            console.log("Ocean touch start");
            e.preventDefault(); 
            touchActive = true;
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                updateTouch(touch);
                const now = (Date.now() - startTime) / 1000.0;
                const camZ = now * 2.0;
                const worldPos = screenToWorld(touch.clientX, touch.clientY, camZ);
                createSplash(worldPos.x, worldPos.z, now);
                lastTouchTime = now;
            }
        }

        function handleTouchMove(e) {
            console.log("Ocean touch move");
            e.preventDefault(); 
            if (e.touches.length > 0 && touchActive) {
                const touch = e.touches[0];
                updateTouch(touch);
                const now = (Date.now() - startTime) / 1000.0;
                if (now - lastTouchTime > 0.2) { 
                    const camZ = now * 2.0;
                    const worldPos = screenToWorld(touch.clientX, touch.clientY, camZ);
                    createSplash(worldPos.x, worldPos.z, now);
                    lastTouchTime = now;
                }
            }
        }

        function handleTouchEnd(e) {
            console.log("Ocean touch end");
            e.preventDefault(); 
            touchActive = false;
        }

        function updateTouch(touch) {
            mouse.x = touch.clientX / window.innerWidth;
            mouse.y = 1.0 - touch.clientY / window.innerHeight;
        }

        function animate() {
            if (!gl) return; 
            const time = (Date.now() - startTime) / 1000.0;

            for (let i = 0; i < MAX_SPLASHES; i++) {
                if (splashes[i].active === 1) {
                    const age = time - splashes[i].time;
                    if (age > 10) { 
                        splashes[i].active = 0;
                    }
                }
            }

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1); 
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.uniform1f(gl.getUniformLocation(program, 'iTime'), time);
            gl.uniform2f(gl.getUniformLocation(program, 'iResolution'), canvas.width, canvas.height);
            gl.uniform2f(gl.getUniformLocation(program, 'iMouse'), mouse.x * 2.0 - 1.0, (mouse.y * 2.0 - 1.0));

            for (let i = 0; i < MAX_SPLASHES; i++) {
                const splashLocation = gl.getUniformLocation(program, 'iSplashes[' + i + ']');
                gl.uniform4f(splashLocation,
                    splashes[i].worldX,
                    splashes[i].worldZ,
                    splashes[i].active === 1 ? splashes[i].time : 0.0, 
                    splashes[i].active 
                );
                const propsLocation = gl.getUniformLocation(program, 'iSplashProps[' + i + ']');
                gl.uniform3f(propsLocation,
                    splashes[i].strength,
                    splashes[i].particleCount,
                    0.0 
                );
            }

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }

        function createProgram(glContext, vertSource, fragSource) {
            const vertShader = glContext.createShader(glContext.VERTEX_SHADER);
            glContext.shaderSource(vertShader, vertSource);
            glContext.compileShader(vertShader);
            if (!glContext.getShaderParameter(vertShader, glContext.COMPILE_STATUS)) {
                console.error('Vertex shader compilation error:', glContext.getShaderInfoLog(vertShader));
            }

            const fragShader = glContext.createShader(glContext.FRAGMENT_SHADER);
            glContext.shaderSource(fragShader, fragSource);
            glContext.compileShader(fragShader);
            if (!glContext.getShaderParameter(fragShader, glContext.COMPILE_STATUS)) {
                console.error('Fragment shader compilation error:', glContext.getShaderInfoLog(fragShader));
            }

            const shaderProgram = glContext.createProgram();
            glContext.attachShader(shaderProgram, vertShader);
            glContext.attachShader(shaderProgram, fragShader);
            glContext.linkProgram(shaderProgram);
            if (!glContext.getProgramParameter(shaderProgram, glContext.LINK_STATUS)) {
                console.error('Shader program linking error:', glContext.getProgramInfoLog(shaderProgram));
            }
            return shaderProgram;
        }

        const vertexShader = `
            attribute vec2 aPosition;
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

        const fragmentShader = `
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec2 iMouse; 
            uniform vec4 iSplashes[${MAX_SPLASHES}]; 
            uniform vec3 iSplashProps[${MAX_SPLASHES}]; 

            const int NUM_STEPS = 5; 
            const float PI = 3.14159265359;
            const float EPSILON = 1e-3; 

            // Sea parameters
            const int ITER_GEOMETRY = 3; 
            const int ITER_FRAGMENT = 4; 
            const float SEA_HEIGHT = 0.6;
            const float SEA_CHOPPY = 4.0;
            const float SEA_SPEED = 0.8;
            const float SEA_FREQ = 0.16;
            const vec3 SEA_BASE = vec3(0.01, 0.12, 0.50);      
            const vec3 SEA_WATER_COLOR = vec3(0.08, 0.28, 0.88);  

            // Bird simulation constants
            const int NUM_BIRDS = 35; 
            const float BIRD_SIZE = 0.0035;

            mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6); 

            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x), cos(ang.x));
                vec2 a2 = vec2(sin(ang.y), cos(ang.y));
                vec2 a3 = vec2(sin(ang.z), cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);
                m[1] = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);
                m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);
                return m;
            }

            float hash(vec2 p) {
                float h = dot(p, vec2(127.1, 311.7));
                return fract(sin(h) * 43758.5453123);
            }
            
            float hash1(float n) {
                return fract(sin(n) * 43758.5453);
            }

            vec2 hash2(float n) {
                return fract(sin(vec2(n, n + 1.0)) * vec2(43758.5453, 22578.1459));
            }


            float noise(in vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                vec2 u = f * f * (3.0 - 2.0 * f); 
                return -1.0 + 2.0 * mix(
                    mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),
                    mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x),
                    u.y);
            }

            float diffuse(vec3 n, vec3 l, float p) { return pow(dot(n, l) * 0.4 + 0.6, p); }
            float specular(vec3 n, vec3 l, vec3 e, float s) {
                float nrm = (s + 8.0) / (PI * 8.0);
                return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
            }
            
            // --- Boid Flocking Logic ---

            void getBoidState(float id, float time, out vec2 pos, out vec2 vel) {
                float aspectRatio = iResolution.x / iResolution.y;
                float initialTime = hash1(id) * 1000.0;
                float t = time + initialTime;
                
                float flockId = floor(id / 7.0); 
                
                // COHESION: Reduced the spread of flock centers to bring them closer.
                vec2 flockCenter = (hash2(flockId) - 0.5) * 1.0; // Was 2.0
                
                // COHESION: Reduced the personal offset to make boids within a flock tighter.
                vec2 personalOffset = (hash2(id * 2.0) - 0.5) * 0.2; // Was 0.5
                
                float angle = t * 0.05 + hash1(flockId) * 2.0 * PI;
                vec2 basePos = vec2(cos(angle), sin(angle) * 0.2) * (aspectRatio * 0.8);
                
                float personalAngle = t * 0.2 + hash1(id * 3.0) * 2.0 * PI;
                vec2 personalMotion = vec2(cos(personalAngle), sin(personalAngle)) * 0.2;
                
                // COHESION: Reduced the influence of the flock center, further tightening groups.
                pos = basePos + flockCenter * 0.2 + personalMotion + personalOffset; // Was flockCenter * 0.5
                
                pos.y = pos.y * 0.4 + 0.5;

                vec2 velAngle = vec2(-sin(angle), cos(angle) * 0.2) * (aspectRatio * 0.8) * 0.05;
                vec2 velPersonal = vec2(-sin(personalAngle), cos(personalAngle)) * 0.2 * 0.2;
                vel = velAngle + velPersonal;
            }

            vec4 renderBirds(vec2 fragCoord) {
                vec4 birdColor = vec4(0.0);
            
                for (int i = 0; i < NUM_BIRDS; i++) {
                    float id = float(i);
                    vec2 pos, vel;
                    getBoidState(id, iTime, pos, vel);
            
                    float depth = mix(0.3, 1.0, pos.y * 0.5 + hash1(id * 5.0) * 0.5);
            
                    vec2 direction = normalize(vel);
                    mat2 rotation = mat2(direction.x, -direction.y, direction.y, direction.x);
                    
                    vec2 uv = (fragCoord - pos);
                    uv = uv / (BIRD_SIZE * depth);
                    uv = rotation * uv;

                    // Slower flapping
                    float flap = sin(iTime * 8.0 - id); 

                    float birdShape = 0.0;
                    if (abs(uv.x) < 2.0 && abs(uv.y + abs(uv.x) * (0.5 + flap * 0.2)) < 0.5) {
                        birdShape = 1.0;
                    }
                    
                    if (birdShape > 0.5) {
                        birdColor = vec4(0.0, 0.0, 0.0, 1.0);
                    }
                }
                return birdColor;
            }

            // Sky Color Function (Purple Sky)
            vec3 getSkyColor(vec3 e) { 
                vec3 normalizedEyeDir = normalize(e);
                float eyeDotUp = max(normalizedEyeDir.y, 0.0); 

                vec3 skyColorHorizon = vec3(0.45, 0.35, 0.65); 
                vec3 skyColorZenith  = vec3(0.25, 0.15, 0.45); 

                vec3 sky = mix(skyColorHorizon, skyColorZenith, pow(eyeDotUp, 0.7));

                vec3 sunDirection = normalize(vec3(0.0, 0.6, 0.7)); 
                float sunIntensityFactor = pow(max(dot(normalizedEyeDir, sunDirection), 0.0), 48.0); 
                float sunGlowFactor = pow(max(dot(normalizedEyeDir, sunDirection), 0.0), 8.0);  

                sky += vec3(1.0, 0.85, 0.9) * sunIntensityFactor * 0.45; 
                sky += vec3(0.95, 0.8, 0.9) * sunGlowFactor * 0.15;    
                
                sky *= 0.8; 

                return clamp(sky, 0.0, 1.0);
            }


            float sea_octave(vec2 uv, float choppy) {
                uv += noise(uv);
                vec2 wv = 1.0 - abs(sin(uv));
                vec2 swv = abs(cos(uv));
                wv = mix(wv, swv, wv);
                return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
            }

            float calculateSplash(vec3 p, vec4 splashData, vec3 props) {
                if (splashData.w <= 0.0) return 0.0; 
                float clickAge = iTime - splashData.z; 
                if (clickAge > 8.0 || clickAge < 0.0) return 0.0; 
                float strength = props.x; 
                vec2 splashCenter = splashData.xy; 
                float distToCenter = length(p.xz - splashCenter);
                float rippleSpeed = 4.0 + strength * 2.0;
                float rippleWidth = 0.5 + strength * 0.5;
                float rippleEffect = 0.0;
                for (float i = 1.0; i <= 2.0; i += 1.0) {
                    float currentRingRadius = clickAge * rippleSpeed * (0.5 * i);
                    float ringProfile = exp(-pow(distToCenter - currentRingRadius, 2.0) / (rippleWidth * i));
                    rippleEffect += sin(distToCenter * (10.0 / i) - clickAge * 20.0) * ringProfile;
                }
                return strength * rippleEffect * smoothstep(0.0, 1.5, clickAge) * smoothstep(8.0, 6.5, clickAge) * 0.3;
            }

            float map_base(vec3 p) { 
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75; 
                float d, h = 0.0;
                for(int i = 0; i < ITER_GEOMETRY; i++) {
                    d = sea_octave((uv + iTime * SEA_SPEED) * freq, choppy);
                    d += sea_octave((uv - iTime * SEA_SPEED) * freq, choppy); 
                    h += d * amp;
                    uv *= octave_m; freq *= 1.9; amp *= 0.22;
                    choppy = mix(choppy, 1.0, 0.2); 
                }
                return p.y - h;
            }

            float map_detailed(vec3 p) { 
                float h_base = map_base(p) - p.y; 
                float splash_effect = 0.0;
                for (int i = 0; i < ${MAX_SPLASHES}; ++i) {
                    if (iSplashes[i].w > 0.0) { 
                        splash_effect += calculateSplash(p, iSplashes[i], iSplashProps[i]);
                    }
                }
                return p.y - (h_base + splash_effect);
            }

            vec3 getNormal(vec3 p, float eps) {
                vec2 e = vec2(eps, 0.0);
                float H = map_detailed(p); 
                float Hx = map_detailed(p + e.xyy) - H; 
                float Hz = map_detailed(p + e.yxy) - H; 
                return normalize(vec3(-Hx, eps, -Hz)); 
            }

            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {
                float tm = 0.0; 
                float tx = 1000.0; 
                float hm = map_base(ori + dir * tm); 
                if(hm > 0.0 && dir.y > -0.01) return tx; 
                float hx = map_base(ori + dir * tx); 
                if(hx > 0.0) return tx; 
                float tmid = 0.0;
                for(int i = 0; i < NUM_STEPS + 2; i++) { 
                    tmid = mix(tm, tx, hm / (hm - hx)); 
                    p = ori + dir * tmid;
                    float hmid = map_base(p);
                    if(hmid < 0.0) { 
                        tx = tmid;
                        hx = hmid;
                    } else { 
                        tm = tmid;
                        hm = hmid;
                    }
                }
                p = ori + dir * tmid;
                return tmid; 
            }

            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 distVec) {
                float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
                fresnel = pow(fresnel, 3.0) * 0.65;

                vec3 reflected_sky = getSkyColor(reflect(eye, n));
                vec3 refracted_water = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12;

                vec3 color = mix(refracted_water, reflected_sky, fresnel);

                float distVal = length(distVec); 
                float atten = max(1.0 - distVal * distVal * 0.00001, 0.0); 
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten; 

                float wave_y = map_base(p) - p.y; 
                float foam_threshold = SEA_HEIGHT * 0.8; 
                float foam_factor = smoothstep(foam_threshold - 0.15, foam_threshold + 0.1, -wave_y); 
                color = mix(color, vec3(0.9, 0.95, 1.0), foam_factor * 0.08 * atten); 

                color += vec3(specular(n, l, eye, 70.0)) * atten * 0.8; 
                return color;
            }

            void main() {
                vec2 uv_norm = gl_FragCoord.xy / iResolution.xy; 
                vec2 p_screen = uv_norm * 2.0 - 1.0; 
                p_screen.x *= iResolution.x / iResolution.y; 

                vec3 camAng = vec3(0.0, -0.1, 0.0); 
                vec3 camPos = vec3(0.0, 5.0, iTime * SEA_SPEED * 2.0); 

                vec3 rayDir = normalize(vec3(p_screen.xy, -2.0)); 
                rayDir = fromEuler(camAng) * rayDir; 

                vec3 hitPos; 
                float distToHit = heightMapTracing(camPos, rayDir, hitPos); 

                vec3 color;
                vec3 lightDir = normalize(vec3(0.0, 0.6, 0.7)); 

                if (distToHit >= 1000.0 - EPSILON) { 
                    color = getSkyColor(rayDir);
                    
                    vec4 bird_color = renderBirds(p_screen);
                    if (bird_color.a > 0.5) {
                        color = bird_color.rgb;
                    }
                } else {
                    vec3 normal = getNormal(hitPos, EPSILON * distToHit * 0.1); 
                    color = getSeaColor(hitPos, normal, lightDir, rayDir, hitPos - camPos);
                }

                color = pow(color, vec3(0.75)); 
                color = mix(vec3(dot(color, vec3(0.299, 0.587, 0.114))), color, 1.0); 

                gl_FragColor = vec4(color, 1.0);
            }
        `;
    </script>
</body>
</html>
