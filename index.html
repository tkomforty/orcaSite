<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    
    <!-- Open Graph / Social Media Preview Tags -->
    <meta property="og:title" content="Orcas Audio - Creative Audio Effects">
    <meta property="og:description" content="Professional VST plugins featuring ocean-inspired audio processing. Undertow reverb/delay, HarmBass saturation, and Quad Cascade delay effects.">
    <meta property="og:image" content="https://raw.githubusercontent.com/tkomforty/orcaSite/main/orca_Site_preview.png">
    <meta property="og:image:width" content="1200">
    <meta property="og:image:height" content="630">
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://orcasaudio.com">
    
    <!-- Twitter Card Tags -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Orcas Audio - Creative Audio Effects">
    <meta name="twitter:description" content="Professional VST plugins featuring ocean-inspired audio processing.">
    <meta name="twitter:image" content="https://raw.githubusercontent.com/tkomforty/orcaSite/main/orca_Site_preview.png">
    
    <title>Orcas Audio - Creative Audio Effects</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow-x: hidden;
            background: #000;
            font-family: 'Inter', sans-serif;
        }

        canvas#oceanCanvas {
            display: block;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            z-index: 0;
        }

        /* Content Layer */
        .content-layer {
            position: relative;
            z-index: 1;
            padding: 40px;
            min-height: 100vh;
        }

        /* Typography */
        .title {
            font-size: 3em;
            font-weight: 700;
            font-style: italic;
            color: #000;
            margin-bottom: 20px;
            text-align: left;
        }

        .header {
            font-size: 2em;
            font-weight: 600;
            color: #000;
            margin-bottom: 40px;
            text-align: left;
        }

        .section-divider {
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #000;
            margin: 40px 0;
            white-space: pre;
            line-height: 1;
        }

        .plugin-section {
            margin-bottom: 60px;
        }

        .plugin-title {
            font-size: 1.8em;
            font-weight: 600;
            color: #000;
            margin-bottom: 20px;
        }

        .plugin-content {
            display: flex;
            gap: 40px;
            align-items: flex-start;
        }

        .plugin-image {
            flex: 0 0 400px;
            max-width: 400px;
        }

        .plugin-image img {
            width: 100%;
            height: auto;
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
        }

        .plugin-info {
            flex: 1;
            color: #000;
        }

        .plugin-description {
            font-size: 1.1em;
            line-height: 1.6;
            margin-bottom: 20px;
        }

        .plugin-features {
            list-style: none;
            margin-bottom: 25px;
        }

        .plugin-features li {
            padding: 4px 0;
            position: relative;
            padding-left: 20px;
        }

        .plugin-features li::before {
            content: "â€¢";
            position: absolute;
            left: 0;
            font-weight: bold;
        }

        .plugin-price {
            font-size: 1.5em;
            font-weight: 700;
            color: #000;
            margin-bottom: 15px;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .content-layer {
                padding: 20px;
            }
            
            .title {
                font-size: 2.5em;
                text-align: center;
            }
            
            .header {
                font-size: 1.5em;
                text-align: center;
            }

            .plugin-content {
                flex-direction: column;
                gap: 20px;
            }

            .plugin-image {
                flex: none;
                max-width: 100%;
            }

            .plugin-title,
            .plugin-description,
            .plugin-features,
            .plugin-price {
                text-align: center;
            }
        }

        @supports (-webkit-touch-callout: none) {
            html, body {
                height: -webkit-fill-available;
            }
        }
    </style>
</head>
<body>
    <!-- Content Layer -->
    <div class="content-layer">
        <h1 class="title">orcas audio</h1>
        <h2 class="header">creative audio effects</h2>
        
        <div class="section-divider">//==============================================================================</div>
        
        <div class="plugin-section">
            <h3 class="plugin-title">Undertow</h3>
            <div class="plugin-content">
                <div class="plugin-image">
                    <img src="https://raw.githubusercontent.com/tkomforty/orcaSite/main/undertowVST.png" 
                         alt="Undertow VST Plugin Interface">
                </div>
                <div class="plugin-info">
                    <p class="plugin-description">
                        Dive deep into immersive soundscapes with an
                        advanced reverb algorithm paired with innovative delay processing. Create waves of audio that ebb and flow with musical velocity.
                    </p>
                    <ul class="plugin-features">
                        <li>Advanced Reverb Engine with freeze-control for atmosphere creation</li>
                        <li>Inline Analog Delay with Tempo Sync</li>
                        <li>Analog inspired soft-clipper for harmonic saturation</li>
                        <li>Low CPU Usage for Studio or Live Performance</li>
                        <li>Compatible with All Major DAWs in VST3 format (AU coming soon)</li>
                    </ul>
                    <div class="plugin-price">$19</div>
                </div>
            </div>
        </div>
        
        <div class="section-divider">//==============================================================================</div>
        
        <div class="plugin-section">
            <h3 class="plugin-title">HarmBass</h3>
            <div class="plugin-content">
                <div class="plugin-image">
                    <img src="https://raw.githubusercontent.com/tkomforty/orcaSite/main/HarmBass.png" 
                         alt="HarmBass VST Plugin Interface">
                </div>
                <div class="plugin-info">
                    <p class="plugin-description">
                        Transform your low end with this powerful bass harmonic saturator featuring four meticulously 
                        modeled distortion algorithms based on real hardware. Add warmth, grit, and character to your bass 
                        tracks with precision frequency control and authentic analog saturation.
                    </p>
                    <ul class="plugin-features">
                        <li>Four distortion algorithms modeled after real hardware units</li>
                        <li>Dedicated bass frequency control for targeted saturation</li>
                        <li>Soft clipper algorithm for smooth harmonic enhancement</li>
                        <li>Analog-modeled saturation for authentic vintage warmth</li>
                        <li>Low CPU usage optimized for bass processing</li>
                        <li>Compatible with All Major DAWs in VST3 format (AU coming soon)</li>
                    </ul>
                    <div class="plugin-price">$19</div>
                </div>
            </div>
        </div>
        
        <div class="section-divider">//==============================================================================</div>
        
        <div class="plugin-section">
            <h3 class="plugin-title">Quad Cascade</h3>
            <div class="plugin-content">
                <div class="plugin-image">
                    <img src="https://raw.githubusercontent.com/tkomforty/orcaSite/main/quad%20cascade.png" 
                         alt="Quad Cascade VST Plugin Interface">
                </div>
                <div class="plugin-info">
                    <p class="plugin-description">
                        Create cascading echoes and complex rhythmic patterns with a simple, but complex  
                        4-stage series analog delay. Each stage features independent feedback and gain controls, 
                        allowing for intricate delay textures and evolving soundscapes that build upon themselves.
                    </p>
                    <ul class="plugin-features">
                        <li>4-stage series analog delay for complex echo patterns</li>
                        <li>Independent feedback control for each delay stage</li>
                        <li>Individual gain controls for precise level balancing</li>
                        <li>Built-in soft clipper for warm analog saturation</li>
                        <li>Level trim control for optimal output management</li>
                        <li>Compatible with All Major DAWs in VST3 format (AU coming soon)</li>
                    </ul>
                    <div class="plugin-price">$19</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let canvas, gl;
        let program;
        let startTime = Date.now();
        let mouse = { x: 0, y: 0 };
        let splashes = [];
        const MAX_SPLASHES = 10;

        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);

        window.onload = function() {
            canvas = document.createElement('canvas');
            canvas.id = 'oceanCanvas';
            document.body.insertBefore(canvas, document.body.firstChild);

            resize();

            const contextAttributes = {
                alpha: false, antialias: false, preserveDrawingBuffer: false, stencil: false,
                depth: false, failIfMajorPerformanceCaveat: false, powerPreference: "default"
            };

            gl = canvas.getContext('webgl2', contextAttributes);
            if (!gl) {
                gl = canvas.getContext('webgl', contextAttributes) ||
                     canvas.getContext('experimental-webgl', contextAttributes);
            }

            if (!gl) {
                const msg = document.createElement('div');
                msg.style.color = 'white'; msg.style.position = 'absolute';
                msg.style.top = '50%'; msg.style.left = '50%';
                msg.style.transform = 'translate(-50%, -50%)';
                msg.style.zIndex = '2';
                msg.innerHTML = 'Your browser does not support WebGL, which is required for the background animation.';
                document.body.appendChild(msg);
                return;
            }

            gl.clear(gl.COLOR_BUFFER_BIT);

            program = createProgram(gl, vertexShader, fragmentShader);

            const vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

            const positionLocation = gl.getAttribLocation(program, 'aPosition');
            gl.enableVertexAttribArray(positionLocation);
            gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

            window.addEventListener('resize', resize, false);

            const unlockAudio = function() {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createBufferSource();
                source.buffer = audioContext.createBuffer(1, 1, 22050);
                source.connect(audioContext.destination);
                source.start(0);
                document.body.removeEventListener('touchstart', unlockAudio);
                document.body.removeEventListener('touchend', unlockAudio);
                document.body.removeEventListener('click', unlockAudio);
            };
            document.body.addEventListener('touchstart', unlockAudio, {passive: true, once: true});
            document.body.addEventListener('click', unlockAudio, {passive: true, once: true});

            canvas.addEventListener('touchstart', handleTouchStart, {passive: false});
            canvas.addEventListener('touchmove', handleTouchMove, {passive: false});
            canvas.addEventListener('touchend', handleTouchEnd, {passive: false});
            canvas.addEventListener('touchcancel', handleTouchEnd, {passive: false});

            canvas.addEventListener('mousemove', updateMouse, false);
            canvas.addEventListener('mousedown', handleClick, false);

            for (let i = 0; i < MAX_SPLASHES; i++) {
                splashes.push({ active: 0, worldX: 0, worldZ: 0, time: 0, strength: 0, particleCount: 0 });
            }

            animate();

            setTimeout(function() {
                resize();
                if (isIOS) {
                    console.log("iOS detected, initializing touch handling for ocean sim");
                }
            }, 100);

            console.log("Ocean User Agent: " + navigator.userAgent);
            console.log("Is iOS: " + isIOS);
            console.log("Max Touch points: " + navigator.maxTouchPoints);
        };

        function resize() {
            let width = window.innerWidth;
            let height = window.innerHeight;

            if (isIOS) {
                const isLandscape = window.innerWidth > window.innerHeight;
                if (isLandscape) {
                    width = document.documentElement.clientWidth;
                    height = document.documentElement.clientHeight;
                }
            }

            const pixelRatio = window.devicePixelRatio || 1;
            if (canvas) {
                canvas.width = width * pixelRatio;
                canvas.height = height * pixelRatio;
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                if (gl) {
                    gl.viewport(0, 0, canvas.width, canvas.height);
                }
            }
            console.log(`Ocean Canvas resized: ${width}x${height}, Pixel ratio: ${pixelRatio}`);
        }

        function updateMouse(e) {
            e.preventDefault();
            mouse.x = e.clientX / window.innerWidth;
            mouse.y = 1.0 - e.clientY / window.innerHeight;
        }

        function screenToWorld(screenX, screenY, camZ) {
            if (screenX.clientX !== undefined) {
                screenY = screenX.clientY;
                screenX = screenX.clientX;
            }
            const aspectRatio = canvas.width / canvas.height;
            const x = ((screenX / window.innerWidth) * 2.0 - 1.0) * aspectRatio;
            const y = ((window.innerHeight - screenY) / window.innerHeight) * 2.0 - 1.0;
            const cameraHeight = 5.0;
            let dirX = x;
            let dirY = -2.0; 
            let dirZ = y; 
            const length = Math.sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);
            const normDirX = dirX / length;
            const normDirY = dirY / length;
            const normDirZ = dirZ / length;
            const t = -cameraHeight / normDirZ; 
            const worldX = 0 + normDirX * t; 
            const worldZRender = camZ + normDirY * t; 
            return { x: worldX, z: worldZRender };
        }

        function handleClick(e) {
            e.preventDefault();
            const now = (Date.now() - startTime) / 1000.0;
            const camZ = now * 2.0; 
            const worldPos = screenToWorld(e.clientX, e.clientY, camZ);
            createSplash(worldPos.x, worldPos.z, now);
        }

        function createSplash(worldX, worldZ, now) {
            let oldestIndex = 0;
            let oldestTime = Infinity;
            for (let i = 0; i < MAX_SPLASHES; i++) {
                if (splashes[i].active === 0) {
                    oldestIndex = i;
                    break;
                }
                if (splashes[i].time < oldestTime) {
                    oldestTime = splashes[i].time;
                    oldestIndex = i;
                }
            }
            const strength = 0.3 + Math.random() * 0.3;
            const particleCount = 3 + Math.floor(Math.random() * 3);
            splashes[oldestIndex] = {
                active: 1, worldX: worldX, worldZ: worldZ,
                time: now, strength: strength, particleCount: particleCount
            };
            console.log("Splash created at (world):", worldX.toFixed(2), worldZ.toFixed(2), "time:", now.toFixed(2));
        }

        let touchActive = false;
        let lastTouchTime = 0;

        function handleTouchStart(e) {
            console.log("Ocean touch start");
            e.preventDefault(); 
            touchActive = true;
            if (e.touches.length > 0) {
                const touch = e.touches[0];
                updateTouch(touch);
                const now = (Date.now() - startTime) / 1000.0;
                const camZ = now * 2.0;
                const worldPos = screenToWorld(touch.clientX, touch.clientY, camZ);
                createSplash(worldPos.x, worldPos.z, now);
                lastTouchTime = now;
            }
        }

        function handleTouchMove(e) {
            console.log("Ocean touch move");
            e.preventDefault(); 
            if (e.touches.length > 0 && touchActive) {
                const touch = e.touches[0];
                updateTouch(touch);
                const now = (Date.now() - startTime) / 1000.0;
                if (now - lastTouchTime > 0.2) { 
                    const camZ = now * 2.0;
                    const worldPos = screenToWorld(touch.clientX, touch.clientY, camZ);
                    createSplash(worldPos.x, worldPos.z, now);
                    lastTouchTime = now;
                }
            }
        }

        function handleTouchEnd(e) {
            console.log("Ocean touch end");
            e.preventDefault(); 
            touchActive = false;
        }

        function updateTouch(touch) {
            mouse.x = touch.clientX / window.innerWidth;
            mouse.y = 1.0 - touch.clientY / window.innerHeight;
        }

        function animate() {
            if (!gl) return; 
            const time = (Date.now() - startTime) / 1000.0;

            for (let i = 0; i < MAX_SPLASHES; i++) {
                if (splashes[i].active === 1) {
                    const age = time - splashes[i].time;
                    if (age > 10) { 
                        splashes[i].active = 0;
                    }
                }
            }

            gl.viewport(0, 0, canvas.width, canvas.height);
            gl.clearColor(0, 0, 0, 1); 
            gl.clear(gl.COLOR_BUFFER_BIT);

            gl.useProgram(program);
            gl.uniform1f(gl.getUniformLocation(program, 'iTime'), time);
            gl.uniform2f(gl.getUniformLocation(program, 'iResolution'), canvas.width, canvas.height);
            gl.uniform2f(gl.getUniformLocation(program, 'iMouse'), mouse.x * 2.0 - 1.0, (mouse.y * 2.0 - 1.0));

            for (let i = 0; i < MAX_SPLASHES; i++) {
                const splashLocation = gl.getUniformLocation(program, 'iSplashes[' + i + ']');
                gl.uniform4f(splashLocation,
                    splashes[i].worldX,
                    splashes[i].worldZ,
                    splashes[i].active === 1 ? splashes[i].time : 0.0, 
                    splashes[i].active 
                );
                const propsLocation = gl.getUniformLocation(program, 'iSplashProps[' + i + ']');
                gl.uniform3f(propsLocation,
                    splashes[i].strength,
                    splashes[i].particleCount,
                    0.0 
                );
            }

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(animate);
        }

        function createProgram(glContext, vertSource, fragSource) {
            const vertShader = glContext.createShader(glContext.VERTEX_SHADER);
            glContext.shaderSource(vertShader, vertSource);
            glContext.compileShader(vertShader);
            if (!glContext.getShaderParameter(vertShader, glContext.COMPILE_STATUS)) {
                console.error('Vertex shader compilation error:', glContext.getShaderInfoLog(vertShader));
            }

            const fragShader = glContext.createShader(glContext.FRAGMENT_SHADER);
            glContext.shaderSource(fragShader, fragSource);
            glContext.compileShader(fragShader);
            if (!glContext.getShaderParameter(fragShader, glContext.COMPILE_STATUS)) {
                console.error('Fragment shader compilation error:', glContext.getShaderInfoLog(fragShader));
            }

            const shaderProgram = glContext.createProgram();
            glContext.attachShader(shaderProgram, vertShader);
            glContext.attachShader(shaderProgram, fragShader);
            glContext.linkProgram(shaderProgram);
            if (!glContext.getProgramParameter(shaderProgram, glContext.LINK_STATUS)) {
                console.error('Shader program linking error:', glContext.getProgramInfoLog(shaderProgram));
            }
            return shaderProgram;
        }

        const vertexShader = `
            attribute vec2 aPosition;
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

        const fragmentShader = `
            #ifdef GL_ES
            precision highp float;
            #endif

            uniform vec2 iResolution;
            uniform float iTime;
            uniform vec2 iMouse; 
            uniform vec4 iSplashes[${MAX_SPLASHES}]; 
            uniform vec3 iSplashProps[${MAX_SPLASHES}]; 

            const int NUM_STEPS = 5; 
            const float PI = 3.14159265359;
            const float EPSILON = 1e-3; 

            // Sea parameters
            const int ITER_GEOMETRY = 3; 
            const int ITER_FRAGMENT = 4; 
            const float SEA_HEIGHT = 0.6;
            const float SEA_CHOPPY = 4.0;
            const float SEA_SPEED = 0.8;
            const float SEA_FREQ = 0.16;
            const vec3 SEA_BASE = vec3(0.01, 0.12, 0.50);        
            const vec3 SEA_WATER_COLOR = vec3(0.08, 0.28, 0.88);  

            mat2 octave_m = mat2(1.6, 1.2, -1.2, 1.6); 

            mat3 fromEuler(vec3 ang) {
                vec2 a1 = vec2(sin(ang.x), cos(ang.x));
                vec2 a2 = vec2(sin(ang.y), cos(ang.y));
                vec2 a3 = vec2(sin(ang.z), cos(ang.z));
                mat3 m;
                m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x, a1.y*a2.x*a3.x+a3.y*a1.x, -a2.y*a3.x);
                m[1] = vec3(-a2.y*a1.x, a1.y*a2.y, a2.x);
                m[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x, a1.x*a3.x-a1.y*a3.y*a2.x, a2.y*a3.y);
                return m;
            }

            float hash(vec2 p) {
                float h = dot(p, vec2(127.1, 311.7));
                return fract(sin(h) * 43758.5453123);
            }

            float noise(in vec2 p) {
                vec2 i = floor(p);
                vec2 f = fract(p);
                vec2 u = f * f * (3.0 - 2.0 * f); 
                return -1.0 + 2.0 * mix(
                    mix(hash(i + vec2(0.0,0.0)), hash(i + vec2(1.0,0.0)), u.x),
                    mix(hash(i + vec2(0.0,1.0)), hash(i + vec2(1.0,1.0)), u.x),
                    u.y);
            }

            float diffuse(vec3 n, vec3 l, float p) { return pow(dot(n, l) * 0.4 + 0.6, p); }
            float specular(vec3 n, vec3 l, vec3 e, float s) {
                float nrm = (s + 8.0) / (PI * 8.0);
                return pow(max(dot(reflect(e, n), l), 0.0), s) * nrm;
            }

            // Sky Color Function (Purple Sky)
            vec3 getSkyColor(vec3 e) { 
                vec3 normalizedEyeDir = normalize(e);
                float eyeDotUp = max(normalizedEyeDir.y, 0.0); 

                vec3 skyColorHorizon = vec3(0.45, 0.35, 0.65); 
                vec3 skyColorZenith  = vec3(0.25, 0.15, 0.45); 

                vec3 sky = mix(skyColorHorizon, skyColorZenith, pow(eyeDotUp, 0.7));

                vec3 sunDirection = normalize(vec3(0.0, 0.6, 0.7)); 
                float sunIntensityFactor = pow(max(dot(normalizedEyeDir, sunDirection), 0.0), 48.0); 
                float sunGlowFactor = pow(max(dot(normalizedEyeDir, sunDirection), 0.0), 8.0);  

                sky += vec3(1.0, 0.85, 0.9) * sunIntensityFactor * 0.45; 
                sky += vec3(0.95, 0.8, 0.9) * sunGlowFactor * 0.15;    
                
                sky *= 0.8; 

                return clamp(sky, 0.0, 1.0);
            }


            float sea_octave(vec2 uv, float choppy) {
                uv += noise(uv);
                vec2 wv = 1.0 - abs(sin(uv));
                vec2 swv = abs(cos(uv));
                wv = mix(wv, swv, wv);
                return pow(1.0 - pow(wv.x * wv.y, 0.65), choppy);
            }

            float calculateSplash(vec3 p, vec4 splashData, vec3 props) {
                if (splashData.w <= 0.0) return 0.0; 
                float clickAge = iTime - splashData.z; 
                if (clickAge > 8.0 || clickAge < 0.0) return 0.0; 
                float strength = props.x; 
                vec2 splashCenter = splashData.xy; 
                float distToCenter = length(p.xz - splashCenter);
                float rippleSpeed = 4.0 + strength * 2.0;
                float rippleWidth = 0.5 + strength * 0.5;
                float rippleEffect = 0.0;
                for (float i = 1.0; i <= 2.0; i += 1.0) {
                    float currentRingRadius = clickAge * rippleSpeed * (0.5 * i);
                    float ringProfile = exp(-pow(distToCenter - currentRingRadius, 2.0) / (rippleWidth * i));
                    rippleEffect += sin(distToCenter * (10.0 / i) - clickAge * 20.0) * ringProfile;
                }
                return strength * rippleEffect * smoothstep(0.0, 1.5, clickAge) * smoothstep(8.0, 6.5, clickAge) * 0.3;
            }

            float map_base(vec3 p) { 
                float freq = SEA_FREQ;
                float amp = SEA_HEIGHT;
                float choppy = SEA_CHOPPY;
                vec2 uv = p.xz; uv.x *= 0.75; 
                float d, h = 0.0;
                for(int i = 0; i < ITER_GEOMETRY; i++) {
                    d = sea_octave((uv + iTime * SEA_SPEED) * freq, choppy);
                    d += sea_octave((uv - iTime * SEA_SPEED) * freq, choppy); 
                    h += d * amp;
                    uv *= octave_m; freq *= 1.9; amp *= 0.22;
                    choppy = mix(choppy, 1.0, 0.2); 
                }
                return p.y - h;
            }

            float map_detailed(vec3 p) { 
                float h_base = map_base(p) - p.y; 
                float splash_effect = 0.0;
                for (int i = 0; i < ${MAX_SPLASHES}; ++i) {
                    if (iSplashes[i].w > 0.0) { 
                         splash_effect += calculateSplash(p, iSplashes[i], iSplashProps[i]);
                    }
                }
                return p.y - (h_base + splash_effect);
            }

            vec3 getNormal(vec3 p, float eps) {
                vec2 e = vec2(eps, 0.0);
                float H = map_detailed(p); 
                float Hx = map_detailed(p + e.xyy) - H; 
                float Hz = map_detailed(p + e.yxy) - H; 
                return normalize(vec3(-Hx, eps, -Hz)); 
            }

            float heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {
                float tm = 0.0; 
                float tx = 1000.0; 
                float hm = map_base(ori + dir * tm); 
                if(hm > 0.0 && dir.y > -0.01) return tx; 
                float hx = map_base(ori + dir * tx); 
                if(hx > 0.0) return tx; 
                float tmid = 0.0;
                for(int i = 0; i < NUM_STEPS + 2; i++) { 
                    tmid = mix(tm, tx, hm / (hm - hx)); 
                    p = ori + dir * tmid;
                    float hmid = map_base(p);
                    if(hmid < 0.0) { 
                        tx = tmid;
                        hx = hmid;
                    } else { 
                        tm = tmid;
                        hm = hmid;
                    }
                }
                p = ori + dir * tmid;
                return tmid; 
            }

            vec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 distVec) {
                float fresnel = clamp(1.0 - dot(n, -eye), 0.0, 1.0);
                fresnel = pow(fresnel, 3.0) * 0.65;

                vec3 reflected_sky = getSkyColor(reflect(eye, n));
                vec3 refracted_water = SEA_BASE + diffuse(n, l, 80.0) * SEA_WATER_COLOR * 0.12;

                vec3 color = mix(refracted_water, reflected_sky, fresnel);

                float distVal = length(distVec); 
                float atten = max(1.0 - distVal * distVal * 0.00001, 0.0); 
                color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten; 

                float wave_y = map_base(p) - p.y; 
                float foam_threshold = SEA_HEIGHT * 0.8; 
                float foam_factor = smoothstep(foam_threshold - 0.15, foam_threshold + 0.1, -wave_y); 
                color = mix(color, vec3(0.9, 0.95, 1.0), foam_factor * 0.08 * atten); 

                color += vec3(specular(n, l, eye, 70.0)) * atten * 0.8; 
                return color;
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / iResolution.xy; 
                vec2 p_screen = uv * 2.0 - 1.0; 
                p_screen.x *= iResolution.x / iResolution.y; 

                vec3 camAng = vec3(0.0, -0.1, 0.0); 
                vec3 camPos = vec3(0.0, 5.0, iTime * SEA_SPEED * 2.0); 

                vec3 rayDir = normalize(vec3(p_screen.xy, -2.0)); 
                rayDir = fromEuler(camAng) * rayDir; 

                vec3 hitPos; 
                float distToHit = heightMapTracing(camPos, rayDir, hitPos); 

                vec3 color;
                vec3 lightDir = normalize(vec3(0.0, 0.6, 0.7)); 

                if (distToHit >= 1000.0 - EPSILON) { 
                    color = getSkyColor(rayDir);
                } else {
                    vec3 normal = getNormal(hitPos, EPSILON * distToHit * 0.1); 
                    color = getSeaColor(hitPos, normal, lightDir, rayDir, hitPos - camPos);
                }

                color = pow(color, vec3(0.75)); 
                color = mix(vec3(dot(color, vec3(0.299, 0.587, 0.114))), color, 1.0); 

                gl_FragColor = vec4(color, 1.0);
            }
        `;
    </script>
</body>
</html>
